# 决赛第一阶段文档

## 入口函数

> arg, envp, auxv参数传递规则

```c
argc, argv[0], ..., argv[argc-1], 0, environ[0], ..., environ[N], 0,
auxv[0].a_type, auxv[0].a_value, ..., 0
```

```c
------------------------------------------------------------- 0x7fff6c845000
 0x7fff6c844ff8: 0x0000000000000000
        _  4fec: './stackdump\0'                      <------+
  env  /   4fe2: 'ENVVAR2=2\0'                               |    <----+
       \_  4fd8: 'ENVVAR1=1\0'                               |   <---+ |
       /   4fd4: 'two\0'                                     |       | |     <----+
 args |    4fd0: 'one\0'                                     |       | |    <---+ |
       \_  4fcb: 'zero\0'                                    |       | |   <--+ | |
           3020: random gap padded to 16B boundary           |       | |      | | |
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -|       | |      | | |
           3019: 'x86_64\0'                        <-+       |       | |      | | |
 auxv      3009: random data: ed99b6...2adcc7        | <-+   |       | |      | | |
 data      3000: zero padding to align stack         |   |   |       | |      | | |
. . . . . . . . . . . . . . . . . . . . . . . . . . .|. .|. .|       | |      | | |
           2ff0: AT_NULL(0)=0                        |   |   |       | |      | | |
           2fe0: AT_PLATFORM(15)=0x7fff6c843019    --+   |   |       | |      | | |
           2fd0: AT_EXECFN(31)=0x7fff6c844fec      ------|---+       | |      | | |
           2fc0: AT_RANDOM(25)=0x7fff6c843009      ------+           | |      | | |
  ELF      2fb0: AT_SECURE(23)=0                                     | |      | | |
auxiliary  2fa0: AT_EGID(14)=1000                                    | |      | | |
 vector:   2f90: AT_GID(13)=1000                                     | |      | | |
(id,val)   2f80: AT_EUID(12)=1000                                    | |      | | |
  pairs    2f70: AT_UID(11)=1000                                     | |      | | |
           2f60: AT_ENTRY(9)=0x4010c0                                | |      | | |
           2f50: AT_FLAGS(8)=0                                       | |      | | |
           2f40: AT_BASE(7)=0x7ff6c1122000                           | |      | | |
           2f30: AT_PHNUM(5)=9                                       | |      | | |
           2f20: AT_PHENT(4)=56                                      | |      | | |
           2f10: AT_PHDR(3)=0x400040                                 | |      | | |
           2f00: AT_CLKTCK(17)=100                                   | |      | | |
           2ef0: AT_PAGESZ(6)=4096                                   | |      | | |
           2ee0: AT_HWCAP(16)=0xbfebfbff                             | |      | | |
           2ed0: AT_SYSINFO_EHDR(33)=0x7fff6c86b000                  | |      | | |
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        | |      | | |
           2ec8: environ[2]=(nil)                                    | |      | | |
           2ec0: environ[1]=0x7fff6c844fe2         ------------------|-+      | | |
           2eb8: environ[0]=0x7fff6c844fd8         ------------------+        | | |
           2eb0: argv[3]=(nil)                                                | | |
           2ea8: argv[2]=0x7fff6c844fd4            ---------------------------|-|-+
           2ea0: argv[1]=0x7fff6c844fd0            ---------------------------|-+
           2e98: argv[0]=0x7fff6c844fcb            ---------------------------+
 0x7fff6c842e90: argc=3 
```

## 更新内核架构

> 后面在实现内核异步时更加容易。

传统的内核将内核执行与任务执行分隔开，在内核进入用户态后所有事务由一个`Interrupt`进行代理。在制作时感到跳跃性较强，因此我准备采用一种另类的设计模式，将每一个任务的执行作为一个`run`函数，在遇到中断时返回，通过在进入任务时保存任务相关寄存器，在发生中断时恢复相关寄存器并`ret`返回原位置。在此中模式下内核设计如同普通的程序一样，连续性较强。`run`后通过另一个`catch`函数进行处理。切换任务时仅需更换当前`task`即可。同样，在实现信号系统时可以直接去执行相应`task`的`run`实现软中断。

## 更加简洁的map

`rust`内置的`BTreeMap`在使用上并不友好，无法进行`new`，因此切换到`HashMap`采取更加间接的`Map`方式。

## 更加有效的内存分配机制

更新内存申请与释放方式，利用`rust`的`Drop`来实现内存的释放。利用`rust`来进行内存管理，极大利用了`rust`的特性，同时进行内存的自动管理，更加高效且安全。

## 完善文件树功能

在文件读取时不是直接对磁盘进行检索，而是先在内核的文件树上进行检索，判断文件是否存在，如果存在则根据文件信息进行读取，如果不存在则报错。

## 虚拟文件机制

程序在读取文件时，先在文件数上进行虚拟文件的创建，然后对相应的虚拟文件分配内存，这样在文件大量、快速读取的环境下更加有效。

## futex

futex是Linux提供的用户内核混合的锁操作，相比于自旋锁，线程在尝试获取futex失败后可以原子地睡眠而不用担心线程因临界区问题导致的无法唤醒的问题。本次实现过程中出现因为未对创建的任务进行有效编号，从而在`kill_task`时杀死多个线程导致的死锁问题，后在调试过程中解决。

## 文件缓冲

在测试案例的执行过程中出现过超时的情况，经测试发现文件读取耗费了大量的时间。因此本次在制作的过程中采用文件缓冲的方式，在系统开始运行时对文件进行预读取，在运行过程中需要读取文件时，首先检索文件是否已经被缓冲，如果已经被缓冲，则返回相应的地址，如果没有被缓存，则进行读取。

## 双页表

在`byteos`中采用双页表结构，即内核一个页表，用户程序一个页表。页表切换发生在进入用户态期间和返回内核态的汇编函数期间。双页表保证了内核可以在执行期间自由的释放进行的资源而不会导致缺页异常，同样更加安全。
